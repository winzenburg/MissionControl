#!/usr/bin/env node

/**
 * Content Factory - Main Orchestrator
 * 
 * Coordinates the full content creation pipeline:
 * 1. Spawn research sub-agent
 * 2. Wait for research results
 * 3. Spawn writing sub-agent with research
 * 4. Compile output
 * 5. Send to Telegram
 * 
 * Usage:
 *   node scripts/content-factory-orchestrate.mjs "Topic" "blog-post"
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs';
import https from 'https';
import path from 'path';

const execAsync = promisify(exec);
const LOG_FILE = './logs/content-factory.log';

const TELEGRAM_BOT_TOKEN = '8565359157:AAE3cA0Tn2OE62K2eaXiXYr1SFqAFkNtzMQ';
const TELEGRAM_CHAT_ID = '5316436116';

function log(message) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] ${message}`);
  if (!fs.existsSync('./logs')) fs.mkdirSync('./logs', { recursive: true });
  fs.appendFileSync(LOG_FILE, `[${timestamp}] ${message}\n`);
}

function sanitizeFilename(str) {
  return str.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
}

async function runResearchAgent(topic) {
  log(`üîç Starting Research Agent for: ${topic}`);
  
  try {
    const { stdout } = await execAsync(`node scripts/content-factory-research.mjs "${topic}"`);
    const research = JSON.parse(stdout);
    log(`‚úì Research complete: ${research.trendingAngles.length} angles, ${research.competitors.length} competitors analyzed`);
    return research;
  } catch (error) {
    log(`‚úó Research agent failed: ${error.message}`);
    throw error;
  }
}

async function runWritingAgent(topic, contentType, research) {
  log(`‚úçÔ∏è Starting Writing Agent for: ${topic} (${contentType})`);
  
  try {
    const researchJson = JSON.stringify(research).replace(/"/g, '\\"');
    const { stdout } = await execAsync(`node scripts/content-factory-write.mjs "${topic}" "${contentType}" "${researchJson}"`);
    log(`‚úì Content draft complete: ${(stdout.length / 1024).toFixed(1)}KB`);
    return stdout;
  } catch (error) {
    log(`‚úó Writing agent failed: ${error.message}`);
    throw error;
  }
}

function compileOutput(topic, contentType, research, draft) {
  const date = new Date().toISOString().split('T')[0];
  const timestamp = new Date().toISOString();
  
  const output = `# Content Factory Output

**Topic:** ${topic}  
**Content Type:** ${contentType}  
**Generated:** ${timestamp}  
**Date:** ${date}  

---

## Research Brief

### Trending Angles (Top 5)

${research.trendingAngles.map(angle => 
  `#### ${angle.rank}. ${angle.angle}
- **Trend:** ${angle.trend}
- **Examples:** ${angle.examples.join(', ')}`
).join('\n\n')}

### Competitor Analysis

${research.competitors.map(comp =>
  `#### ${comp.rank}. ${comp.title}
**Source:** ${comp.source}  
**URL:** ${comp.url}

**Key Points:**
${comp.keyPoints.map(p => `- ${p}`).join('\n')}

**Strengths:** ${comp.strengths.join(', ')}  
**Gaps:** ${comp.gaps.join(', ')}`
).join('\n\n')}

### Common Questions

${research.commonQuestions.map(q =>
  `#### ${q.rank}. ${q.question}
- **Search Volume:** ${q.searchVolume}
- **Intent:** ${q.intent}`
).join('\n\n')}

### Strategic Recommendations

${research.recommendations.map(rec =>
  `- **${rec.type}:** ${rec.insight} (Leverage: ${rec.leverage})`
).join('\n')}

---

## Content Draft

${draft}

---

## Metadata

**Research Sources:** ${research.sources.length} sources analyzed  
**Output Type:** ${contentType}  
**Ready to:** ${contentType === 'youtube-script' ? 'Record & Upload' : contentType === 'blog-post' ? 'Publish & Promote' : 'Schedule & Thread'}  

---

*Generated by Content Factory Pipeline*
`;

  return output;
}

async function sendTelegramMessage(topic, research, draft) {
  log('üì§ Sending Telegram summary...');
  
  const summary = `‚úÖ *Content Factory Complete*

üìå *Topic:* ${topic}

üìä *Research Findings:*
- ${research.trendingAngles[0].angle}
- ${research.trendingAngles[1].angle}
- Search interest: ${research.trendingAngles[0].trend}

‚ùì *Top Questions:*
1. ${research.commonQuestions[0].question}
2. ${research.commonQuestions[1].question}
3. ${research.commonQuestions[2].question}

‚úçÔ∏è *Content Draft:* Ready for review
üìÑ File saved to: \`content/[topic_slug]_[date].md\`

Ready to publish!`;

  return new Promise((resolve) => {
    const payload = JSON.stringify({
      chat_id: TELEGRAM_CHAT_ID,
      text: summary,
      parse_mode: 'Markdown'
    });

    const options = {
      hostname: 'api.telegram.org',
      path: `/bot${TELEGRAM_BOT_TOKEN}/sendMessage`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(payload)
      }
    };

    const req = https.request(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try {
          const result = JSON.parse(data);
          if (result.ok) {
            log('‚úì Telegram message sent');
            resolve(true);
          } else {
            log(`‚ö† Telegram error: ${result.description}`);
            resolve(false);
          }
        } catch (e) {
          resolve(false);
        }
      });
    });

    req.on('error', () => resolve(false));
    req.write(payload);
    req.end();
  });
}

async function main() {
  const topic = process.argv[2];
  const contentType = (process.argv[3] || 'blog-post').toLowerCase();
  
  if (!topic) {
    console.error('Usage: node content-factory-orchestrate.mjs "[TOPIC]" "[blog-post|youtube-script|twitter-thread]"');
    process.exit(1);
  }
  
  log('===== Content Factory Pipeline Start =====');
  log(`Topic: ${topic}`);
  log(`Content Type: ${contentType}`);
  
  try {
    // Step 1: Research
    const research = await runResearchAgent(topic);
    
    // Step 2: Writing
    const draft = await runWritingAgent(topic, contentType, research);
    
    // Step 3: Compile
    log('üì¶ Compiling output...');
    const compiled = compileOutput(topic, contentType, research, draft);
    
    // Step 4: Save
    const date = new Date().toISOString().split('T')[0];
    const filename = `${sanitizeFilename(topic)}_${date}.md`;
    const filepath = path.join('./content', filename);
    
    fs.writeFileSync(filepath, compiled);
    log(`üíæ Saved to: ${filepath}`);
    
    // Step 5: Deliver
    await sendTelegramMessage(topic, research, draft);
    
    // Final output
    console.log(`\n‚úÖ Content Factory Complete!\n`);
    console.log(`üìÑ File: ${filename}`);
    console.log(`üìä Research: ${research.trendingAngles.length} angles, ${research.competitors.length} competitors`);
    console.log(`‚úçÔ∏è Draft: ${(draft.length / 1024).toFixed(1)}KB`);
    console.log(`\nPath: ~/.openclaw/workspace/content/${filename}\n`);
    
    log('===== Content Factory Pipeline Complete =====');
    
  } catch (error) {
    log(`‚úó Pipeline failed: ${error.message}`);
    console.error(`\n‚ùå Content Factory Failed: ${error.message}\n`);
    process.exit(1);
  }
}

main();
